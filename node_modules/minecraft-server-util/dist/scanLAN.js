"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const dgram_1 = __importDefault(require("dgram"));
const util_1 = require("util");
const minecraft_motd_util_1 = require("minecraft-motd-util");
const pattern = /\[MOTD\](.+)?(?=\[\/MOTD\])\[\/MOTD\]\[AD\](\d+)\[\/AD\]/;
const decoder = new util_1.TextDecoder('utf-8');
function applyDefaultOptions(options) {
    // Apply the provided options on the default options
    return Object.assign({
        scanTime: 1000 * 5
    }, options);
}
/**
 * Scans the local area network for any Minecraft worlds.
 * @param {ScanLANOptions} [options] The options to use when scanning LAN
 * @returns {Promise<ScanLANResponse>} The response of the scan
 * @async
 */
function scanLAN(options) {
    return __awaiter(this, void 0, void 0, function* () {
        // Applies the provided options on top of the default options
        const opts = applyDefaultOptions(options);
        // Assert that the arguments are the correct type and format
        (0, assert_1.default)(typeof options === 'object' || typeof options === 'undefined', `Expected 'options' to be an object or undefined, got ${typeof options}`);
        (0, assert_1.default)(typeof opts === 'object', `Expected 'options' to be an object, got ${typeof opts}`);
        (0, assert_1.default)(typeof opts.scanTime === 'number', `Expected 'options.scanTime' to be a number, got ${typeof opts.scanTime}`);
        (0, assert_1.default)(opts.scanTime >= 1500, `Expected 'options.scanTime' to be greater than or equal to 1500, got ${opts.scanTime}`);
        // Create a list of servers that the socket will append to
        const servers = [];
        // Create a new UDP socket and listen for messages
        const socket = dgram_1.default.createSocket('udp4');
        // Wait for messages being broadcased
        socket.on('message', (message, info) => {
            const text = decoder.decode(message);
            // Ensure that the text sent to the scan port matches the "Open to LAN" format
            if (!pattern.test(text))
                return;
            const match = text.match(pattern);
            if (!match)
                return;
            // Parse the port out of the matched text
            const port = parseInt(match[2]);
            if (isNaN(port))
                return;
            const server = servers.find((server) => server.host === info.address && server.port === port);
            if (server)
                return;
            const description = (0, minecraft_motd_util_1.parse)(match[1]);
            const motd = {
                raw: (0, minecraft_motd_util_1.format)(description),
                clean: (0, minecraft_motd_util_1.clean)(description),
                html: (0, minecraft_motd_util_1.toHTML)(description)
            };
            servers.push({
                host: info.address,
                port,
                motd
            });
        });
        // Bind to the 4445 port which is used for receiving and broadcasting "Open to LAN" worlds
        socket.bind(4445, () => {
            socket.addMembership('224.0.2.60');
        });
        // Return the timeout promise that will resolve when the scan time is up
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                resolve({ servers });
                socket.close();
            }, opts.scanTime);
            socket.on('error', (error) => {
                socket.close();
                clearTimeout(timeout);
                reject(error);
            });
        });
    });
}
exports.default = scanLAN;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbkxBTi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zY2FuTEFOLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLGtEQUEwQjtBQUMxQiwrQkFBbUM7QUFDbkMsNkRBQW1FO0FBSW5FLE1BQU0sT0FBTyxHQUFHLDBEQUEwRCxDQUFDO0FBQzNFLE1BQU0sT0FBTyxHQUFHLElBQUksa0JBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUV6QyxTQUFTLG1CQUFtQixDQUFDLE9BQXdCO0lBQ3BELG9EQUFvRDtJQUNwRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDcEIsUUFBUSxFQUFFLElBQUksR0FBRyxDQUFDO0tBQ1UsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUE4QixPQUFPLENBQUMsT0FBd0I7O1FBQzdELDZEQUE2RDtRQUM3RCxNQUFNLElBQUksR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUxQyw0REFBNEQ7UUFDNUQsSUFBQSxnQkFBTSxFQUFDLE9BQU8sT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUUsd0RBQXdELE9BQU8sT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNoSixJQUFBLGdCQUFNLEVBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFLDJDQUEyQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7UUFDM0YsSUFBQSxnQkFBTSxFQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUUsbURBQW1ELE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDckgsSUFBQSxnQkFBTSxFQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFLHdFQUF3RSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUV2SCwwREFBMEQ7UUFDMUQs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